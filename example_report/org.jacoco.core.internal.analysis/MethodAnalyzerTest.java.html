<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/highlight_report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodAnalyzerTest.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco</a> &gt; <a href="index.source.html" class="el_package">org.jacoco.core.internal.analysis</a> &gt; <span class="el_source">MethodAnalyzerTest.java</span></div><h1>MethodAnalyzerTest.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2009, 2016 Mountainminds GmbH &amp; Co. KG and Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Marc R. Hoffmann - initial API and implementation
 *    
 *******************************************************************************/
package org.jacoco.core.internal.analysis;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;

import org.jacoco.core.analysis.ILine;
import org.jacoco.core.analysis.IMethodCoverage;
import org.jacoco.core.internal.flow.IProbeIdGenerator;
import org.jacoco.core.internal.flow.LabelFlowAnalyzer;
import org.jacoco.core.internal.flow.MethodProbesAdapter;
import org.junit.Before;
import org.junit.Test;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TryCatchBlockNode;

/**
 * Unit tests for {@link MethodAnalyzer}.
 */
<span class="fc" id="L33">public class MethodAnalyzerTest implements IProbeIdGenerator {</span>

	private int nextProbeId;

	private boolean[] probes;

	private MethodNode method;

	private IMethodCoverage result;

	@Before
	public void setup() {
<span class="fc" id="L45">		nextProbeId = 0;</span>
<span class="fc" id="L46">		method = new MethodNode();</span>
<span class="fc" id="L47">		method.tryCatchBlocks = new ArrayList&lt;TryCatchBlockNode&gt;();</span>
<span class="fc" id="L48">		probes = new boolean[32];</span>
<span class="fc" id="L49">	}</span>

	public int nextId() {
<span class="fc" id="L52">		return nextProbeId++;</span>
	}

	// === Scenario: linear Sequence without branches ===

	private void createLinearSequence() {
<span class="fc" id="L58">		method.visitLineNumber(1001, new Label());</span>
<span class="fc" id="L59">		method.visitInsn(Opcodes.NOP);</span>
<span class="fc" id="L60">		method.visitLineNumber(1002, new Label());</span>
<span class="fc" id="L61">		method.visitInsn(Opcodes.RETURN);</span>
<span class="fc" id="L62">	}</span>

	@Test
	public void testLinearSequenceNotCovered1() {
<span class="fc" id="L66">		createLinearSequence();</span>
<span class="fc" id="L67">		runMethodAnalzer();</span>
<span class="fc" id="L68">		assertEquals(1, nextProbeId);</span>

<span class="fc" id="L70">		assertLine(1001, 1, 0, 0, 0);</span>
<span class="fc" id="L71">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L72">	}</span>

	@Test
	public void testLinearSequenceNotCovered2() {
<span class="fc" id="L76">		createLinearSequence();</span>
<span class="fc" id="L77">		probes = null;</span>
<span class="fc" id="L78">		runMethodAnalzer();</span>
<span class="fc" id="L79">		assertEquals(1, nextProbeId);</span>

<span class="fc" id="L81">		assertLine(1001, 1, 0, 0, 0);</span>
<span class="fc" id="L82">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L83">	}</span>

	@Test
	public void testLinearSequenceCovered() {
<span class="fc" id="L87">		createLinearSequence();</span>
<span class="fc" id="L88">		probes[0] = true;</span>
<span class="fc" id="L89">		runMethodAnalzer();</span>

<span class="fc" id="L91">		assertLine(1001, 0, 1, 0, 0);</span>
<span class="fc" id="L92">		assertLine(1002, 0, 1, 0, 0);</span>
<span class="fc" id="L93">	}</span>

	// === Scenario: simple if branch ===

	private void createIfBranch() {
<span class="fc" id="L98">		method.visitLineNumber(1001, new Label());</span>
<span class="fc" id="L99">		method.visitVarInsn(Opcodes.ILOAD, 1);</span>
<span class="fc" id="L100">		Label l1 = new Label();</span>
<span class="fc" id="L101">		method.visitJumpInsn(Opcodes.IFEQ, l1);</span>
<span class="fc" id="L102">		method.visitLineNumber(1002, new Label());</span>
<span class="fc" id="L103">		method.visitLdcInsn(&quot;a&quot;);</span>
<span class="fc" id="L104">		method.visitInsn(Opcodes.ARETURN);</span>
<span class="fc" id="L105">		method.visitLabel(l1);</span>
<span class="fc" id="L106">		method.visitLineNumber(1003, l1);</span>
<span class="fc" id="L107">		method.visitLdcInsn(&quot;b&quot;);</span>
<span class="fc" id="L108">		method.visitInsn(Opcodes.ARETURN);</span>
<span class="fc" id="L109">	}</span>

	@Test
	public void testIfBranchNotCovered() {
<span class="fc" id="L113">		createIfBranch();</span>
<span class="fc" id="L114">		runMethodAnalzer();</span>
<span class="fc" id="L115">		assertEquals(2, nextProbeId);</span>

<span class="fc" id="L117">		assertLine(1001, 2, 0, 2, 0);</span>
<span class="fc" id="L118">		assertLine(1002, 2, 0, 0, 0);</span>
<span class="fc" id="L119">		assertLine(1003, 2, 0, 0, 0);</span>
<span class="fc" id="L120">	}</span>

	@Test
	public void testIfBranchCovered1() {
<span class="fc" id="L124">		createIfBranch();</span>
<span class="fc" id="L125">		probes[0] = true;</span>
<span class="fc" id="L126">		runMethodAnalzer();</span>

<span class="fc" id="L128">		assertLine(1001, 0, 2, 1, 1);</span>
<span class="fc" id="L129">		assertLine(1002, 0, 2, 0, 0);</span>
<span class="fc" id="L130">		assertLine(1003, 2, 0, 0, 0);</span>
<span class="fc" id="L131">	}</span>

	@Test
	public void testIfBranchCovered2() {
<span class="fc" id="L135">		createIfBranch();</span>
<span class="fc" id="L136">		probes[1] = true;</span>
<span class="fc" id="L137">		runMethodAnalzer();</span>

<span class="fc" id="L139">		assertLine(1001, 0, 2, 1, 1);</span>
<span class="fc" id="L140">		assertLine(1002, 2, 0, 0, 0);</span>
<span class="fc" id="L141">		assertLine(1003, 0, 2, 0, 0);</span>
<span class="fc" id="L142">	}</span>

	@Test
	public void testIfBranchCovered3() {
<span class="fc" id="L146">		createIfBranch();</span>
<span class="fc" id="L147">		probes[0] = true;</span>
<span class="fc" id="L148">		probes[1] = true;</span>
<span class="fc" id="L149">		runMethodAnalzer();</span>

<span class="fc" id="L151">		assertLine(1001, 0, 2, 0, 2);</span>
<span class="fc" id="L152">		assertLine(1002, 0, 2, 0, 0);</span>
<span class="fc" id="L153">		assertLine(1003, 0, 2, 0, 0);</span>
<span class="fc" id="L154">	}</span>

	// === Scenario: branch which merges back ===

	private void createIfBranchMerge() {
<span class="fc" id="L159">		method.visitLineNumber(1001, new Label());</span>
<span class="fc" id="L160">		method.visitVarInsn(Opcodes.ILOAD, 1);</span>
<span class="fc" id="L161">		Label l1 = new Label();</span>
<span class="fc" id="L162">		method.visitJumpInsn(Opcodes.IFEQ, l1);</span>
<span class="fc" id="L163">		method.visitLineNumber(1002, new Label());</span>
<span class="fc" id="L164">		method.visitInsn(Opcodes.NOP);</span>
<span class="fc" id="L165">		method.visitLabel(l1);</span>
<span class="fc" id="L166">		method.visitLineNumber(1003, l1);</span>
<span class="fc" id="L167">		method.visitInsn(Opcodes.RETURN);</span>
<span class="fc" id="L168">	}</span>

	@Test
	public void testIfBranchMergeNotCovered() {
<span class="fc" id="L172">		createIfBranchMerge();</span>
<span class="fc" id="L173">		runMethodAnalzer();</span>
<span class="fc" id="L174">		assertEquals(3, nextProbeId);</span>

<span class="fc" id="L176">		assertLine(1001, 2, 0, 2, 0);</span>
<span class="fc" id="L177">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L178">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L179">	}</span>

	@Test
	public void testIfBranchMergeCovered1() {
<span class="fc" id="L183">		createIfBranchMerge();</span>
<span class="fc" id="L184">		probes[0] = true;</span>
<span class="fc" id="L185">		runMethodAnalzer();</span>

<span class="fc" id="L187">		assertLine(1001, 0, 2, 1, 1);</span>
<span class="fc" id="L188">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L189">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L190">	}</span>

	@Test
	public void testIfBranchMergeCovered2() {
<span class="fc" id="L194">		createIfBranchMerge();</span>
<span class="fc" id="L195">		probes[1] = true;</span>
<span class="fc" id="L196">		runMethodAnalzer();</span>

<span class="fc" id="L198">		assertLine(1001, 0, 2, 1, 1);</span>
<span class="fc" id="L199">		assertLine(1002, 0, 1, 0, 0);</span>
<span class="fc" id="L200">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L201">	}</span>

	@Test
	public void testIfBranchMergeCovered3() {
<span class="fc" id="L205">		createIfBranchMerge();</span>
<span class="fc" id="L206">		probes[0] = true;</span>
<span class="fc" id="L207">		probes[1] = true;</span>
<span class="fc" id="L208">		probes[2] = true;</span>
<span class="fc" id="L209">		runMethodAnalzer();</span>

<span class="fc" id="L211">		assertLine(1001, 0, 2, 0, 2);</span>
<span class="fc" id="L212">		assertLine(1002, 0, 1, 0, 0);</span>
<span class="fc" id="L213">		assertLine(1003, 0, 1, 0, 0);</span>
<span class="fc" id="L214">	}</span>

	// === Scenario: branch which jump backwards ===

	private void createJumpBackwards() {
<span class="fc" id="L219">		method.visitLineNumber(1001, new Label());</span>
<span class="fc" id="L220">		final Label l1 = new Label();</span>
<span class="fc" id="L221">		method.visitJumpInsn(Opcodes.GOTO, l1);</span>
<span class="fc" id="L222">		final Label l2 = new Label();</span>
<span class="fc" id="L223">		method.visitLabel(l2);</span>
<span class="fc" id="L224">		method.visitLineNumber(1002, l2);</span>
<span class="fc" id="L225">		method.visitInsn(Opcodes.RETURN);</span>
<span class="fc" id="L226">		method.visitLabel(l1);</span>
<span class="fc" id="L227">		method.visitLineNumber(1003, l1);</span>
<span class="fc" id="L228">		method.visitJumpInsn(Opcodes.GOTO, l2);</span>
<span class="fc" id="L229">	}</span>

	@Test
	public void testJumpBackwardsNotCovered() {
<span class="fc" id="L233">		createJumpBackwards();</span>
<span class="fc" id="L234">		runMethodAnalzer();</span>
<span class="fc" id="L235">		assertEquals(1, nextProbeId);</span>

<span class="fc" id="L237">		assertLine(1001, 1, 0, 0, 0);</span>
<span class="fc" id="L238">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L239">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L240">	}</span>

	@Test
	public void testJumpBackwardsCovered() {
<span class="fc" id="L244">		createJumpBackwards();</span>
<span class="fc" id="L245">		probes[0] = true;</span>
<span class="fc" id="L246">		runMethodAnalzer();</span>

<span class="fc" id="L248">		assertLine(1001, 0, 1, 0, 0);</span>
<span class="fc" id="L249">		assertLine(1002, 0, 1, 0, 0);</span>
<span class="fc" id="L250">		assertLine(1003, 0, 1, 0, 0);</span>
<span class="fc" id="L251">	}</span>

	// === Scenario: jump to first instruction ===

	private void createJumpToFirst() {
<span class="fc" id="L256">		final Label l1 = new Label();</span>
<span class="fc" id="L257">		method.visitLabel(l1);</span>
<span class="fc" id="L258">		method.visitLineNumber(1001, l1);</span>
<span class="fc" id="L259">		method.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L260">		method.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;Foo&quot;, &quot;test&quot;, &quot;()Z&quot;,</span>
				false);
<span class="fc" id="L262">		method.visitJumpInsn(Opcodes.IFEQ, l1);</span>
<span class="fc" id="L263">		final Label l2 = new Label();</span>
<span class="fc" id="L264">		method.visitLabel(l2);</span>
<span class="fc" id="L265">		method.visitLineNumber(1002, l2);</span>
<span class="fc" id="L266">		method.visitInsn(Opcodes.RETURN);</span>
<span class="fc" id="L267">	}</span>

	@Test
	public void testJumpToFirstNotCovered() {
<span class="fc" id="L271">		createJumpToFirst();</span>
<span class="fc" id="L272">		runMethodAnalzer();</span>
<span class="fc" id="L273">		assertEquals(2, nextProbeId);</span>

<span class="fc" id="L275">		assertLine(1001, 3, 0, 2, 0);</span>
<span class="fc" id="L276">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L277">	}</span>

	@Test
	public void testJumpToFirstCovered1() {
<span class="fc" id="L281">		createJumpToFirst();</span>
<span class="fc" id="L282">		probes[0] = true;</span>
<span class="fc" id="L283">		runMethodAnalzer();</span>
<span class="fc" id="L284">		assertEquals(2, nextProbeId);</span>

<span class="fc" id="L286">		assertLine(1001, 0, 3, 1, 1);</span>
<span class="fc" id="L287">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L288">	}</span>

	@Test
	public void testJumpToFirstCovered2() {
<span class="fc" id="L292">		createJumpToFirst();</span>
<span class="fc" id="L293">		probes[0] = true;</span>
<span class="fc" id="L294">		probes[1] = true;</span>
<span class="fc" id="L295">		runMethodAnalzer();</span>
<span class="fc" id="L296">		assertEquals(2, nextProbeId);</span>

<span class="fc" id="L298">		assertLine(1001, 0, 3, 0, 2);</span>
<span class="fc" id="L299">		assertLine(1002, 0, 1, 0, 0);</span>
<span class="fc" id="L300">	}</span>

	// === Scenario: table switch ===

	private void createTableSwitch() {
<span class="fc" id="L305">		method.visitLineNumber(1001, new Label());</span>
<span class="fc" id="L306">		method.visitVarInsn(Opcodes.ILOAD, 1);</span>
<span class="fc" id="L307">		Label l1 = new Label();</span>
<span class="fc" id="L308">		Label l2 = new Label();</span>
<span class="fc" id="L309">		Label l3 = new Label();</span>
<span class="fc" id="L310">		method.visitTableSwitchInsn(1, 3, l3, new Label[] { l1, l2, l1 });</span>
<span class="fc" id="L311">		method.visitLabel(l1);</span>
<span class="fc" id="L312">		method.visitLineNumber(1002, l1);</span>
<span class="fc" id="L313">		method.visitIntInsn(Opcodes.BIPUSH, 11);</span>
<span class="fc" id="L314">		method.visitVarInsn(Opcodes.ISTORE, 2);</span>
<span class="fc" id="L315">		method.visitLineNumber(1003, new Label());</span>
<span class="fc" id="L316">		Label l5 = new Label();</span>
<span class="fc" id="L317">		method.visitJumpInsn(Opcodes.GOTO, l5);</span>
<span class="fc" id="L318">		method.visitLabel(l2);</span>
<span class="fc" id="L319">		method.visitLineNumber(1004, l2);</span>
<span class="fc" id="L320">		method.visitIntInsn(Opcodes.BIPUSH, 22);</span>
<span class="fc" id="L321">		method.visitVarInsn(Opcodes.ISTORE, 2);</span>
<span class="fc" id="L322">		method.visitLineNumber(1005, new Label());</span>
<span class="fc" id="L323">		method.visitJumpInsn(Opcodes.GOTO, l5);</span>
<span class="fc" id="L324">		method.visitLabel(l3);</span>
<span class="fc" id="L325">		method.visitLineNumber(1006, l3);</span>
<span class="fc" id="L326">		method.visitInsn(Opcodes.ICONST_0);</span>
<span class="fc" id="L327">		method.visitVarInsn(Opcodes.ISTORE, 2);</span>
<span class="fc" id="L328">		method.visitLabel(l5);</span>
<span class="fc" id="L329">		method.visitLineNumber(1007, l5);</span>
<span class="fc" id="L330">		method.visitVarInsn(Opcodes.ILOAD, 2);</span>
<span class="fc" id="L331">		method.visitInsn(Opcodes.IRETURN);</span>
<span class="fc" id="L332">	}</span>

	@Test
	public void testTableSwitchNotCovered() {
<span class="fc" id="L336">		createTableSwitch();</span>
<span class="fc" id="L337">		runMethodAnalzer();</span>
<span class="fc" id="L338">		assertEquals(4, nextProbeId);</span>

<span class="fc" id="L340">		assertLine(1001, 2, 0, 3, 0);</span>
<span class="fc" id="L341">		assertLine(1002, 2, 0, 0, 0);</span>
<span class="fc" id="L342">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L343">		assertLine(1004, 2, 0, 0, 0);</span>
<span class="fc" id="L344">		assertLine(1005, 1, 0, 0, 0);</span>
<span class="fc" id="L345">		assertLine(1006, 2, 0, 0, 0);</span>
<span class="fc" id="L346">		assertLine(1007, 2, 0, 0, 0);</span>
<span class="fc" id="L347">	}</span>

	@Test
	public void testTableSwitchCovered1() {
<span class="fc" id="L351">		createTableSwitch();</span>
<span class="fc" id="L352">		probes[0] = true;</span>
<span class="fc" id="L353">		probes[3] = true;</span>
<span class="fc" id="L354">		runMethodAnalzer();</span>
<span class="fc" id="L355">		assertEquals(4, nextProbeId);</span>

<span class="fc" id="L357">		assertLine(1001, 0, 2, 2, 1);</span>
<span class="fc" id="L358">		assertLine(1002, 0, 2, 0, 0);</span>
<span class="fc" id="L359">		assertLine(1003, 0, 1, 0, 0);</span>
<span class="fc" id="L360">		assertLine(1004, 2, 0, 0, 0);</span>
<span class="fc" id="L361">		assertLine(1005, 1, 0, 0, 0);</span>
<span class="fc" id="L362">		assertLine(1006, 2, 0, 0, 0);</span>
<span class="fc" id="L363">		assertLine(1007, 0, 2, 0, 0);</span>
<span class="fc" id="L364">	}</span>

	@Test
	public void testTableSwitchCovered2() {
<span class="fc" id="L368">		createTableSwitch();</span>
<span class="fc" id="L369">		probes[2] = true;</span>
<span class="fc" id="L370">		probes[3] = true;</span>
<span class="fc" id="L371">		runMethodAnalzer();</span>
<span class="fc" id="L372">		assertEquals(4, nextProbeId);</span>

<span class="fc" id="L374">		assertLine(1001, 0, 2, 2, 1);</span>
<span class="fc" id="L375">		assertLine(1002, 2, 0, 0, 0);</span>
<span class="fc" id="L376">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L377">		assertLine(1004, 2, 0, 0, 0);</span>
<span class="fc" id="L378">		assertLine(1005, 1, 0, 0, 0);</span>
<span class="fc" id="L379">		assertLine(1006, 0, 2, 0, 0);</span>
<span class="fc" id="L380">		assertLine(1007, 0, 2, 0, 0);</span>
<span class="fc" id="L381">	}</span>

	@Test
	public void testTableSwitchCovered3() {
<span class="fc" id="L385">		createTableSwitch();</span>
<span class="fc" id="L386">		probes[0] = true;</span>
<span class="fc" id="L387">		probes[1] = true;</span>
<span class="fc" id="L388">		probes[2] = true;</span>
<span class="fc" id="L389">		probes[3] = true;</span>
<span class="fc" id="L390">		runMethodAnalzer();</span>
<span class="fc" id="L391">		assertEquals(4, nextProbeId);</span>

<span class="fc" id="L393">		assertLine(1001, 0, 2, 0, 3);</span>
<span class="fc" id="L394">		assertLine(1002, 0, 2, 0, 0);</span>
<span class="fc" id="L395">		assertLine(1003, 0, 1, 0, 0);</span>
<span class="fc" id="L396">		assertLine(1004, 0, 2, 0, 0);</span>
<span class="fc" id="L397">		assertLine(1005, 0, 1, 0, 0);</span>
<span class="fc" id="L398">		assertLine(1006, 0, 2, 0, 0);</span>
<span class="fc" id="L399">		assertLine(1007, 0, 2, 0, 0);</span>
<span class="fc" id="L400">	}</span>

	// === Scenario: table switch with merge ===

	private void createTableSwitchMerge() {
<span class="fc" id="L405">		method.visitLineNumber(1001, new Label());</span>
<span class="fc" id="L406">		method.visitInsn(Opcodes.ICONST_0);</span>
<span class="fc" id="L407">		method.visitVarInsn(Opcodes.ISTORE, 2);</span>
<span class="fc" id="L408">		method.visitLineNumber(1002, new Label());</span>
<span class="fc" id="L409">		method.visitVarInsn(Opcodes.ILOAD, 1);</span>
<span class="fc" id="L410">		Label l2 = new Label();</span>
<span class="fc" id="L411">		Label l3 = new Label();</span>
<span class="fc" id="L412">		Label l4 = new Label();</span>
<span class="fc" id="L413">		method.visitTableSwitchInsn(1, 3, l4, new Label[] { l2, l3, l2 });</span>
<span class="fc" id="L414">		method.visitLabel(l2);</span>
<span class="fc" id="L415">		method.visitLineNumber(1003, l2);</span>
<span class="fc" id="L416">		method.visitIincInsn(2, 1);</span>
<span class="fc" id="L417">		method.visitLabel(l3);</span>
<span class="fc" id="L418">		method.visitLineNumber(1004, l3);</span>
<span class="fc" id="L419">		method.visitIincInsn(2, 1);</span>
<span class="fc" id="L420">		method.visitLabel(l4);</span>
<span class="fc" id="L421">		method.visitLineNumber(1005, l4);</span>
<span class="fc" id="L422">		method.visitVarInsn(Opcodes.ILOAD, 2);</span>
<span class="fc" id="L423">		method.visitInsn(Opcodes.IRETURN);</span>
<span class="fc" id="L424">	}</span>

	@Test
	public void testTableSwitchMergeNotCovered() {
<span class="fc" id="L428">		createTableSwitchMerge();</span>
<span class="fc" id="L429">		runMethodAnalzer();</span>
<span class="fc" id="L430">		assertEquals(5, nextProbeId);</span>

<span class="fc" id="L432">		assertLine(1001, 2, 0, 0, 0);</span>
<span class="fc" id="L433">		assertLine(1002, 2, 0, 3, 0);</span>
<span class="fc" id="L434">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L435">		assertLine(1004, 1, 0, 0, 0);</span>
<span class="fc" id="L436">		assertLine(1005, 2, 0, 0, 0);</span>
<span class="fc" id="L437">	}</span>

	@Test
	public void testTableSwitchMergeNotCovered1() {
<span class="fc" id="L441">		createTableSwitchMerge();</span>
<span class="fc" id="L442">		probes[0] = true;</span>
<span class="fc" id="L443">		probes[4] = true;</span>
<span class="fc" id="L444">		runMethodAnalzer();</span>
<span class="fc" id="L445">		assertEquals(5, nextProbeId);</span>

<span class="fc" id="L447">		assertLine(1001, 0, 2, 0, 0);</span>
<span class="fc" id="L448">		assertLine(1002, 0, 2, 2, 1);</span>
<span class="fc" id="L449">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L450">		assertLine(1004, 1, 0, 0, 0);</span>
<span class="fc" id="L451">		assertLine(1005, 0, 2, 0, 0);</span>
<span class="fc" id="L452">	}</span>

	@Test
	public void testTableSwitchMergeNotCovered2() {
<span class="fc" id="L456">		createTableSwitchMerge();</span>
<span class="fc" id="L457">		probes[1] = true;</span>
<span class="fc" id="L458">		probes[3] = true;</span>
<span class="fc" id="L459">		probes[4] = true;</span>
<span class="fc" id="L460">		runMethodAnalzer();</span>
<span class="fc" id="L461">		assertEquals(5, nextProbeId);</span>

<span class="fc" id="L463">		assertLine(1001, 0, 2, 0, 0);</span>
<span class="fc" id="L464">		assertLine(1002, 0, 2, 2, 1);</span>
<span class="fc" id="L465">		assertLine(1003, 1, 0, 0, 0);</span>
<span class="fc" id="L466">		assertLine(1004, 0, 1, 0, 0);</span>
<span class="fc" id="L467">		assertLine(1005, 0, 2, 0, 0);</span>
<span class="fc" id="L468">	}</span>

	@Test
	public void testTableSwitchMergeNotCovered3() {
<span class="fc" id="L472">		createTableSwitchMerge();</span>
<span class="fc" id="L473">		probes[2] = true;</span>
<span class="fc" id="L474">		probes[3] = true;</span>
<span class="fc" id="L475">		probes[4] = true;</span>
<span class="fc" id="L476">		runMethodAnalzer();</span>
<span class="fc" id="L477">		assertEquals(5, nextProbeId);</span>

<span class="fc" id="L479">		assertLine(1001, 0, 2, 0, 0);</span>
<span class="fc" id="L480">		assertLine(1002, 0, 2, 2, 1);</span>
<span class="fc" id="L481">		assertLine(1003, 0, 1, 0, 0);</span>
<span class="fc" id="L482">		assertLine(1004, 0, 1, 0, 0);</span>
<span class="fc" id="L483">		assertLine(1005, 0, 2, 0, 0);</span>
<span class="fc" id="L484">	}</span>

	@Test
	public void testTableSwitchMergeNotCovered4() {
<span class="fc" id="L488">		createTableSwitchMerge();</span>
<span class="fc" id="L489">		probes[0] = true;</span>
<span class="fc" id="L490">		probes[1] = true;</span>
<span class="fc" id="L491">		probes[2] = true;</span>
<span class="fc" id="L492">		probes[3] = true;</span>
<span class="fc" id="L493">		probes[4] = true;</span>
<span class="fc" id="L494">		runMethodAnalzer();</span>
<span class="fc" id="L495">		assertEquals(5, nextProbeId);</span>

<span class="fc" id="L497">		assertLine(1001, 0, 2, 0, 0);</span>
<span class="fc" id="L498">		assertLine(1002, 0, 2, 0, 3);</span>
<span class="fc" id="L499">		assertLine(1003, 0, 1, 0, 0);</span>
<span class="fc" id="L500">		assertLine(1004, 0, 1, 0, 0);</span>
<span class="fc" id="L501">		assertLine(1005, 0, 2, 0, 0);</span>
<span class="fc" id="L502">	}</span>

	// === Scenario: try/catch block ===

	private void createTryCatchBlock() {
<span class="fc" id="L507">		Label l1 = new Label();</span>
<span class="fc" id="L508">		Label l2 = new Label();</span>
<span class="fc" id="L509">		Label l3 = new Label();</span>
<span class="fc" id="L510">		Label l4 = new Label();</span>
<span class="fc" id="L511">		method.visitTryCatchBlock(l1, l2, l3, &quot;java/lang/Exception&quot;);</span>
<span class="fc" id="L512">		method.visitLabel(l1);</span>
<span class="fc" id="L513">		method.visitLineNumber(1001, l1);</span>
<span class="fc" id="L514">		method.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="fc" id="L515">		method.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Throwable&quot;,</span>
				&quot;printStackTrace&quot;, &quot;()V&quot;, false);
<span class="fc" id="L517">		method.visitLabel(l2);</span>
<span class="fc" id="L518">		method.visitJumpInsn(Opcodes.GOTO, l4);</span>
<span class="fc" id="L519">		method.visitLabel(l3);</span>
<span class="fc" id="L520">		method.visitLineNumber(1002, l3);</span>
<span class="fc" id="L521">		method.visitVarInsn(Opcodes.ASTORE, 1);</span>
<span class="fc" id="L522">		method.visitLabel(l4);</span>
<span class="fc" id="L523">		method.visitLineNumber(1004, l4);</span>
<span class="fc" id="L524">		method.visitInsn(Opcodes.RETURN);</span>
<span class="fc" id="L525">	}</span>

	@Test
	public void testTryCatchBlockNotCovered() {
<span class="fc" id="L529">		createTryCatchBlock();</span>
<span class="fc" id="L530">		runMethodAnalzer();</span>
<span class="fc" id="L531">		assertEquals(3, nextProbeId);</span>
<span class="fc" id="L532">		assertEquals(CounterImpl.getInstance(5, 0),</span>
				result.getInstructionCounter());

<span class="fc" id="L535">		assertLine(1001, 3, 0, 0, 0);</span>
<span class="fc" id="L536">		assertLine(1002, 1, 0, 0, 0);</span>
<span class="fc" id="L537">		assertLine(1004, 1, 0, 0, 0);</span>
<span class="fc" id="L538">	}</span>

	@Test
	public void testTryCatchBlockFullyCovered() {
<span class="fc" id="L542">		createTryCatchBlock();</span>
<span class="fc" id="L543">		probes[0] = true;</span>
<span class="fc" id="L544">		probes[1] = true;</span>
<span class="fc" id="L545">		probes[2] = true;</span>
<span class="fc" id="L546">		runMethodAnalzer();</span>
<span class="fc" id="L547">		assertEquals(3, nextProbeId);</span>
<span class="fc" id="L548">		assertEquals(CounterImpl.getInstance(0, 5),</span>
				result.getInstructionCounter());

<span class="fc" id="L551">		assertLine(1001, 0, 3, 0, 0);</span>
<span class="fc" id="L552">		assertLine(1002, 0, 1, 0, 0);</span>
<span class="fc" id="L553">		assertLine(1004, 0, 1, 0, 0);</span>
<span class="fc" id="L554">	}</span>

	private void runMethodAnalzer() {
<span class="fc" id="L557">		LabelFlowAnalyzer.markLabels(method);</span>
<span class="fc" id="L558">		final MethodAnalyzer analyzer = new MethodAnalyzer(&quot;doit&quot;, &quot;()V&quot;, null,</span>
				probes);
<span class="fc" id="L560">		final MethodProbesAdapter probesAdapter = new MethodProbesAdapter(</span>
				analyzer, this);
<span class="fc" id="L562">		method.accept(probesAdapter);</span>
<span class="fc" id="L563">		result = analyzer.getCoverage();</span>
<span class="fc" id="L564">	}</span>

	private void assertLine(int nr, int insnMissed, int insnCovered,
			int branchesMissed, int branchesCovered) {
<span class="fc" id="L568">		final ILine line = result.getLine(nr);</span>
<span class="fc" id="L569">		assertEquals(&quot;Instructions in line &quot; + nr,</span>
				CounterImpl.getInstance(insnMissed, insnCovered),
				line.getInstructionCounter());
<span class="fc" id="L572">		assertEquals(&quot;Branches in line &quot; + nr,</span>
				CounterImpl.getInstance(branchesMissed, branchesCovered),
				line.getBranchCounter());
<span class="fc" id="L575">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>